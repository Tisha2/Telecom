\documentclass[12pt]{article}

\usepackage[cp1251]{inputenc}  %% 1
\usepackage[T2A]{fontenc}      %% 2
\usepackage[russian]{babel}    %% 3

\usepackage{graphicx}
\graphicspath{}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}


\usepackage{pscyr}
\voffset = 0pt
\topmargin = 0pt
 \headsep = 0pt

\setlength{\textheight}{45\baselineskip}
\setlength{\textheight}{\baselinestretch\textheight}
\addtolength{\textheight}{\topskip}

\begin{document}
\thispagestyle{empty}

\centerline{Телекоммуникационные технологии}


\vspace{30ex}

\centerline{\huge{Отчет по лабораторной работе № 12}}
\vspace{1ex}
\centerline{\Large{Тема:}}
\vspace{1ex}
\centerline{\LARGE\textbf{Модуляция и демодуляция сигнала}}
\vspace{15ex}

\centerline{\LARGE{Самсонов Сергей}}
\vspace{54ex}
\centerline{2021}

\textit{Упражнение 12.1}\\
\textbf{Задание:} Для передачи сигнала используется модулятор ( Constellation Modulator Block ), кодировщик
символов Constellaton Rect. Object и генератор байтовых значений. Посмотреть, как избыточная
пропускная способность влияет на форму фильтра.\\
\textbf{Решение:} Данный Flow Graph осуществляет передачу QPSK, показывая переданный сигнал,
полученный на приемнике сигнал во времени и частотах и «созвездие».\\
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{1.png}}
	\caption{Flow Graph mpsk-rrc-rolloff}
\end{figure}\\

\textbf{Заключение:}
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{2.png}}
		\caption{График mpsk-rrc-rolloff}
\end{figure}
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{3.png}}
	\caption{График mpsk-stage1}
\end{figure}\\

Изменения excess bandwidth влияют на то, насколько крутыми будуи границы (насколько плавно
они будут понижаться).


На символ у нас идет 4 сэмпла. Это можно судить по увеличению дискретизации на созвездии.
Фильтрация осуществляется путем вставки RRC-фильтром межсимвольных помех. На самом деле данный
прием искажает принятый сигнал (размываются символы). Чтобы это поправить, добавим RRC-фильтр
для приемника. Таким образом при свертке получаются импульсы приподнятого косинуса, при этом
минимизируются помехи.\\

\textit{Упражнение 12.2}\\
\textbf{Задание:} При помощи Channel Model добавим искажения в канале передач, чтобы сымитировать шум
(регулируется напряжением).
Нужно учесть, что разные домены тактовых сигналов в приемнике и передатчике могут вызвать сдвиг.
Есть еще одна проблема: приемник не знает идеальную точку сэмплирования.
\textbf{Решение:} 
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{4.png}}
	\caption{Flow Graph mpsk-stage2}
\end{figure}\\
Все выше указанные проблемы можно сымитировать и настроить при помощи нашего Flow
Graph, а также при помощи него можно наблюдать их влияние на сигнал.


\textbf{Заключение:} 
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{5.png}}
\end{figure}\\
Получилось что-то бесформенное и явно не то, что нам нужно. Значит имитации
проблем (по крайней мере некоторых из них) - работают.\\

\textit{Упражнение 12.3}\\
\textbf{Задание:} Для восстановления времени, нам нужно отыскать наилучшее время для сэмплинга входящего
сигнала, чтобы максимизировать SNR и минимизировать ISI.\\
\textbf{Решение:} 
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{6.png}}
	\caption{Flow Graph symbol-sampling}
\end{figure}
Следующий Flow Graph иллюстрирует проблему ISI, мы тут создаем 4 символа-единицы
подряд, а затем фильтруем их:
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{7.png}}
	\caption{График symbol-sampling}
\end{figure}



\textbf{Заключение:} 
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{8.png}}
	\caption{Flow Graph symbol-sampling-diff}
\end{figure}
Теперь посмотрим на эффект разных доменов тактовых сигналов на передатчике и
приемнике. Разница во времени специально завышена для наглядности.
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{9.png}}
\end{figure}
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{10.png}}
	\caption{График symbol-sampling-diff}
\end{figure}
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{11.png}}
	\caption{График symbol-differential-filter}
\end{figure}
Для синхронизации используем техникой восстановления polyphase filterbank. Во-первых, она
решит проблему с тактовыми доменами. Во- вторых, уменьшит ISI. В-третьих, понизит частоту
дискретизации сигнала и будет производить по 1 сэмплу на символ.
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{12.png}}
	\caption{Flow Graph symbol-differential-filter-phases}
\end{figure}\\
Можно попробовать переделать Flow Graph, чтобы перебрать разные фильтры с разными сдвигами
по фазе, чтобы определить наиболее подходящий сдвиг.
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{13.png}}
	\caption{График symbol-differential-filter-phases}
\end{figure}\\
Теперь можно настроить блок синхронизации полифазного тактирующего сигнала в приемнике.
Нужно настроить 32 фильтра:
Слева полученный сигнал до восстановления, а справа соответственно сигнал,
уже прошедший фильтрацию.
Можно отрегулировать Frequency Offset, чтобы минимизировать ошибки в
интерпретации абсолютных значений.
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{14.png}}
	\caption{График mpsk-stage3}
\end{figure}
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{15.png}}
	\caption{График mpsk-stage3 x2}
\end{figure}
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{16.png}}
\end{figure}\\

\textit{Упражнение 12.4}\\
\textbf{Задание:} Сигнал поступает на приемник с множества направлений сразу.\\
\textbf{Решение:} Если сигнал поступает с разных направлений, он может исказиться.
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{17.png}}
	\caption{Flow Graph multipath-sim}
\end{figure}\\
Чтобы это исправить, сделал следующий граф
Здесь будет создан канал с 4 управляемыми параметрами, при установке
некоторых из в 1 соответствующие частоты смогут пройти без помех, а при 0 они
будут производить «глубокий нуль» в спектре (влияет и на соседние частоты).
\textbf{Заключение:} Получается эквалайзер, цель которого преобразить искаженный
сигнал в горизонтальную прямую.
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{18.png}}
	\caption{График multipath-sim}
\end{figure}\\

\textit{Упражнение 12.5}\\
\textbf{Задание:} В GNU Radio есть два удобных встроенных эквалайзера: CMA и LMS DD.
Constant Modulus Algorithm - это «слепой» эквалайзер, но он работает лишь с
сигналами с постоянной амплитудой, что хорошо работает с цифровыми сигналы
вроде MPSK.\\
\textbf{Решение:} Пример ниже демонстрирует MPSK-эквалайзер (параметры подстро-
ены согласно прошлому опыту).
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{19.png}}
	\caption{Flow Graph mpsk-stage4}
\end{figure}\\
Можно видеть, как CMA сходится. Тут и тактирующий сигнал син-
хронизирован, и блок эквалайзера, и сходятся они независимо, но одна стадия
влияет на другую, поэтому некоторое взаимодействие между ними все же есть.

График mpsk-stage4\\

\textbf{Заключение:} Исходный сигнал (слева) хоть и не зашумлен, но все равно выгля-
дит криво. Тем не менее эквалайзер смог инвертировать и избавиться от канала.\\
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{20.png}}
	\caption{Flow Graph mpsk-stage4-lms-dd}
	\caption{График mpsk-stage4-lms-dd}
\end{figure}\\


\textit{Упражнение 12.6}\\
\textbf{Задание:} Поскольку после применения эквалайзера у нас все еще остается проблема
со смещением в фазе и частоте.
Попробуем использовать цикл второго порядка, чтобы следить за фазой и
частотой с течением времени. Кроме того, нужно сделать достаточно хорошую
коррекцию частот для удачного восстановления, поэтому нужно будет убедиться,
что мы достаточно близки к идеальной частоте, иначе цикл не будет сходиться.\\
\textbf{Решение:} 
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{21.png}}
	\caption{Flow Graph mpsk-stage5}
\end{figure}\\
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{22.png}}
	\caption{График mpsk-stage5}
\end{figure}
Воспользуемся циклом Костаса. Соответствующий блок может син-
хронизировать BPSK, QPSK и 8PSK.\\
\textbf{Заключение:} Этот блок, как и все наши другие, использует цикл второго
порядка, а потому и имеет соответствующий параметр, связанный с пропускной
способностью. Ему также нужно знать степень PSK-модуляции (4 для QPSK).
Можно видеть, как после работы эквалайзера все символы расположены на
единичной окружности, но из-за сдвига частот, они как бы «размазаны» по ней, а не
соответствуют нашим 4 точкам. После цикла Костаса мы уже видим ровно 4

исходные точки, но некоторый шум тоже присутствует.\\

\textit{Упражнение 12.7}\\
\textbf{Задание: }Сделать декодер.\\
\textbf{Решение:} После цикла Костаса мы вставляем еще Constellation Decoder ,
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{23.png}}
	\caption{Flow Graph mpsk-stage6}
\end{figure}\\
 но это еще не
все. На этом этапе мы видим символы 0..3, потому что на это рассчитан наш алфавит,
но у нас нет никакой уверенности, что эти 0..3 правильно соответствуют тем 0..3,
что мы передавали изначально. Нам удавалось обходить этот вопрос, потому что мы
использовали дифференциальное кодирование в Constellation Modulator 'e. Выключим
теперь это.
Flow Graph использует блок Differential Decoder , чтобы перевести
дифференциально-закодированные символы обратно в исходные при помощи
сдвигов фаз, а не абсолютной фазы. Но даже так наши символы еще не совсем
верные. Во время синхронизации математика и физика была на нашей стороне, а
теперь нам надо интерпретировать символы, основываясь на том, что кто-т осказал,
какими они были. То есть, нам просто надо знать, как они соотносятся. Для этого
мы воспользуемся блоками Map и Unpack Bit .\\
\textbf{Заключение:} Чтобы убедиться, что теперь мы действительно получаем тот са-
мый поток данных , мы просто сравним, что было в начале, с тем, что получили (ведь
это симуляция, мы имеем доступ к любой информации). Передатчик создает
упакованные биты, поэтому при помощи Unpack Bit мы должны их распаковать из 8
бит на байт в 1 бит на байт, затем превратить их в float 0.0 и 1.0, потому что Time Sink
умеет только float и complex принимать. Но напрямую сравнивать значения пока
нельзя, потому что в приемнике есть еще много узлов, которые задерживают
данные, поэтому нам нужен еще и блок Delay .
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{24.png}}
\end{figure}\\
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{25.png}}
\end{figure}\\
\begin{figure}[h!]
	\center{\includegraphics[scale=0.4]{26.png}}
	\caption{График mpsk-stage}
\end{figure}\\
\end{document}
